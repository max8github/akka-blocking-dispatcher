<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>Managing Blocking in Akka</title>

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/extra.css">
<link rel="stylesheet" href="css/theme/akka.css">

<!-- Theme used for syntax highlighting of code -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>
</head>
<body>


<div class="reveal">
<div class="slides">
<section data-background="#15a9ce">
<h3><a href="#managing-blocking-in-akka" name="managing-blocking-in-akka" class="anchor"><span class="anchor-link"></span></a>Managing Blocking in Akka</h3>
<p><aside class="notes">Hi! I&rsquo;m Arnout from the Akka team, and today, we will look at blocking when using Akka.</aside></p></section><section>
<ol>
  <li>Why is blocking dangerous?</li>
  <li>Using a custom dispatcher</li>
  <li>Project Loom</li>
</ol>
<p><aside class="notes">If you have been using Akka, you have probably heard it is bad to use blocking code inside an actor. In this video we will see:<br>  * why blocking is dangerous<br>  * how you can use a custom dispatcher if you must block<br>  * whether Project Loom will help fix this problem</aside></p></section><section>
<p><img src="images/actors.svg" alt="actors" /></p>
<p><aside class="notes">When programming using actors, each actor receives messages in its mailbox. The actor system will make sure each message for an actor is processed sequentially.</aside></p></section><section>
<p><img src="images/dispatcher-and-actors.svg" alt="dispatcher-and-actors" /></p>
<p><aside class="notes"><p>The internal Akka component that drives the message processing is called the dispatcher. A dispatcher is shared by many actors. Informally, you can think of it as a thread pool that will pick an actor that has messages in its mailbox and is not currently processing. </p><p> Because you have a limited number of CPU&rsquo;s anyway, as long as actors never block it is very efficient to have many more actors than threads. However, when some actors block, that can make your dispatcher run out of threads. </p></aside></p></section><section>
<pre class="prettyprint"><code class="language-scala">import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object PrintActor {
    def apply(): Behavior[Integer] =
      Behaviors.receive { (ctx, i) =&gt;
        ctx.log.info(i.toString)
        Behaviors.same
      }
  }</code></pre>
<pre class="prettyprint"><code class="language-scala">import akka.actor.typed.ActorSystem
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object NoBlocking extends App {
  val root = Behaviors.setup[Nothing] { context =&gt;
    for (i &lt;- 1 to 100) {
      val actor = context.spawn(PrintActor(), s&quot;nonblocking-$i&quot;)
      actor ! i
    }
    Behaviors.empty
  }
  ActorSystem[Nothing](root, &quot;NonBlockingSample&quot;)
}</code></pre>
<p><aside class="notes">Let&rsquo;s show this problem with some code: here we create 100 actors that print the number we send to it.</aside></p></section><section>
<pre><code>[2019-12-12 12:16:19,886] [INFO] [PrintActor$] - 2
[2019-12-12 12:16:19,886] [INFO] [PrintActor$] - 1
[2019-12-12 12:16:19,886] [INFO] [PrintActor$] - 3
[2019-12-12 12:16:19,887] [INFO] [PrintActor$] - 4
[2019-12-12 12:16:19,887] [INFO] [PrintActor$] - 5
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 6
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 7
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 8
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 9
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 10
[2019-12-12 12:16:19,888] [INFO] [PrintActor$] - 11
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 12
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 13
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 14
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 15
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 16
[2019-12-12 12:16:19,889] [INFO] [PrintActor$] - 17
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 18
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 19
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 20
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 21
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 22
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 23
[2019-12-12 12:16:19,890] [INFO] [PrintActor$] - 24
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 25
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 26
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 27
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 28
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 29
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 30
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 31
[2019-12-12 12:16:19,891] [INFO] [PrintActor$] - 32
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 33
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 34
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 35
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 36
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 37
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 38
[2019-12-12 12:16:19,892] [INFO] [PrintActor$] - 39
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 40
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 41
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 43
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 42
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 44
[2019-12-12 12:16:19,893] [INFO] [PrintActor$] - 45
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 46
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 47
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 48
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 49
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 50
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 51
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 52
[2019-12-12 12:16:19,894] [INFO] [PrintActor$] - 53
[2019-12-12 12:16:19,895] [INFO] [PrintActor$] - 54
[2019-12-12 12:16:19,895] [INFO] [PrintActor$] - 55
[2019-12-12 12:16:19,895] [INFO] [PrintActor$] - 56
[2019-12-12 12:16:19,895] [INFO] [PrintActor$] - 57
[2019-12-12 12:16:19,895] [INFO] [PrintActor$] - 58
[2019-12-12 12:16:19,896] [INFO] [PrintActor$] - 59
[2019-12-12 12:16:19,896] [INFO] [PrintActor$] - 60
[2019-12-12 12:16:19,896] [INFO] [PrintActor$] - 61
[2019-12-12 12:16:19,896] [INFO] [PrintActor$] - 62
[2019-12-12 12:16:19,896] [INFO] [PrintActor$] - 63
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 64
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 65
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 66
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 67
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 68
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 69
[2019-12-12 12:16:19,897] [INFO] [PrintActor$] - 70
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 71
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 72
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 73
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 74
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 75
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 76
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 77
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 78
[2019-12-12 12:16:19,898] [INFO] [PrintActor$] - 79
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 80
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 81
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 82
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 83
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 84
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 85
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 86
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 87
[2019-12-12 12:16:19,899] [INFO] [PrintActor$] - 88
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 89
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 90
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 91
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 92
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 93
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 94
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 95
[2019-12-12 12:16:19,900] [INFO] [PrintActor$] - 96
[2019-12-12 12:16:19,901] [INFO] [PrintActor$] - 97
[2019-12-12 12:16:19,901] [INFO] [PrintActor$] - 98
[2019-12-12 12:16:19,901] [INFO] [PrintActor$] - 99
[2019-12-12 12:16:19,901] [INFO] [PrintActor$] - 100
</code></pre>
<p><aside class="notes">All good. Now let&rsquo;s see what happens when we simulate blocking inside half of the actors</aside></p></section><section>
<pre class="prettyprint"><code class="language-scala">import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object BlockingActor {
    def apply(): Behavior[Int] =
      Behaviors.receive { (context, i) =&gt;
        context.log.info(s&quot;Started: $i&quot;)
        //block for 5 seconds, representing blocking I/O, etc
        Thread.sleep(5000)
        context.log.info(s&quot;Finished: $i&quot;)
        Behaviors.same
      }
  }</code></pre>
<pre class="prettyprint"><code class="language-scala">import akka.actor.typed.ActorSystem
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object BlockingWrong extends App {
  val root = Behaviors.setup[Nothing] { context =&gt;
    for (i &lt;- 1 to 50) {
      context.spawn(PrintActor(), s&quot;print-$i&quot;) ! i
      context.spawn(BlockingActor(), s&quot;blocking-$i&quot;) ! i
    }
    Behaviors.empty
  }
  val system = ActorSystem[Nothing](root, &quot;NonBlockingSample&quot;)
}</code></pre>
<p><aside class="notes">We now create 50 non-blocking actors, and 50 actors that block the dispatcher thread.</aside></p></section><section>
<pre><code>[2019-12-12 12:28:14,084] [INFO] [PrintActor$] - 11
[2019-12-12 12:28:14,084] [INFO] [BlockingActor$] - Started: 11
[2019-12-12 12:28:14,085] [INFO] [PrintActor$] - 12
[2019-12-12 12:28:14,085] [INFO] [BlockingActor$] - Started: 12
[2019-12-12 12:28:14,085] [INFO] [PrintActor$] - 13
[2019-12-12 12:28:14,086] [INFO] [BlockingActor$] - Started: 13
[2019-12-12 12:28:14,086] [INFO] [PrintActor$] - 14
[2019-12-12 12:28:14,086] [INFO] [BlockingActor$] - Started: 14
[2019-12-12 12:28:14,086] [INFO] [PrintActor$] - 15
[2019-12-12 12:28:14,087] [INFO] [BlockingActor$] - Started: 15
[2019-12-12 12:28:14,097] [INFO] [PrintActor$] - 16
[2019-12-12 12:28:14,097] [INFO] [BlockingActor$] - Started: 16
</code></pre>
<pre><code>[2019-12-12 12:28:19,077] [INFO] [BlockingActor$] - Finished: 1
[2019-12-12 12:28:19,077] [INFO] [PrintActor$] - 17
[2019-12-12 12:28:19,078] [INFO] [BlockingActor$] - Finished: 2
[2019-12-12 12:28:19,078] [INFO] [BlockingActor$] - Started: 17
[2019-12-12 12:28:19,078] [INFO] [PrintActor$] - 18
[2019-12-12 12:28:19,078] [INFO] [BlockingActor$] - Started: 18
[2019-12-12 12:28:19,079] [INFO] [BlockingActor$] - Finished: 3
</code></pre>
<p><aside class="notes">We see the PrintActor process the first 16 or so messages immediately, but then it is stuck for 5 seconds: all dispatcher threads are busy handling the blocking calls into the blocking actor.</aside></p></section><section data-background="#15a9ce">
<h2><a href="#key-takeaway" name="key-takeaway" class="anchor"><span class="anchor-link"></span></a>key takeaway</h2>
<blockquote>
  <p>Blocking inside an actor is bad, because blocking in one actor can starve the dispatcher and prevent other actors from making progress.</p>
</blockquote>
<p>If you have a <a href="https://www.lightbend.com/lightbend-platform-subscription">Lightbend Subscription</a>, you can configure our <a href="https://doc.akka.io/docs/akka-enhancements/current/starvation-detector.html">Thread Starvation Detector</a> to diagnose such issues.</p></section><section>
<pre class="prettyprint"><code class="language-conf">my-dispatcher-for-blocking {
  type = Dispatcher
  executor = &quot;thread-pool-executor&quot;
  thread-pool-executor {
    fixed-pool-size = 16
  }
  throughput = 1
}</code></pre>
<p>application.conf</p>
<p><aside class="notes">That is good to understand, but what if you really need to block? Sometimes a 3rd-party API provides no alternative to blocking. In such a case, you could introduce a dedicated dispatcher for your blocking calls. Let&rsquo;s return to our example. What we can do is introduce a second dispatcher that is dedicated to running our blocking actors. Such dispatchers are configured in your application.conf</aside></p></section><section>
<pre class="prettyprint"><code class="language-scala">import akka.actor.typed.Dispatchers
import akka.actor.typed.DispatcherSelector

val root = Behaviors.setup[Nothing] { context =&gt;
  for (i &lt;- 1 to 50) {
    context.spawn(PrintActor(), s&quot;future-$i&quot;) ! i
    context.spawn(
      BlockingActor(),
      s&quot;blocking-$i&quot;,
      DispatcherSelector.fromConfig(&quot;my-dispatcher-for-blocking&quot;)
    ) ! i
  }

  Behaviors.empty
}</code></pre>
<p><aside class="notes">We can specify the dispatcher to use when spawning the actors</aside></p></section><section>
<pre><code>[2019-12-12 12:43:41,666] [INFO] [PrintActor$] - 46
[2019-12-12 12:43:41,666] [INFO] [PrintActor$] - 47
[2019-12-12 12:43:41,666] [INFO] [PrintActor$] - 48
[2019-12-12 12:43:41,666] [INFO] [PrintActor$] - 49
[2019-12-12 12:43:41,666] [INFO] [PrintActor$] - 50
[2019-12-12 12:43:46,650] [INFO] [BlockingActor$] - Finished: 1
[2019-12-12 12:43:46,651] [INFO] [BlockingActor$] - Finished: 2
[2019-12-12 12:43:46,651] [INFO] [BlockingActor$] - Started: 18
[2019-12-12 12:43:46,651] [INFO] [BlockingActor$] - Started: 17
[2019-12-12 12:43:46,651] [INFO] [BlockingActor$] - Finished: 3
[2019-12-12 12:43:46,651] [INFO] [BlockingActor$] - Started: 19
</code></pre>
<p><aside class="notes">All 50 messages to our non-blocking actor are immediately delivered, and our blocking actor is still using a limited number of threads</aside></p></section><section>
<h1><a href="#project-loom" name="project-loom" class="anchor"><span class="anchor-link"></span></a>Project Loom</h1>
<p><aside class="notes">You may have heard about Project Loom, a project to bring fibers (cheap threads) to the JVM. TODO: Actors model still useful for managing concurrent access to shared resources, but dispatchers can have many threads, so one blocking actor perhaps wouldn&rsquo;t interfere with other actors anymore. However, when possible, writing your blocking actor as a non-blocking one would still give benefits within that actor, since it allows that actor to process messages while the operation is running.</aside></p></section><section>
<p>TODO final slide with links etc</p></section>
</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
history: true,
slideNumber: true,
dependencies: [
{ src: 'plugin/markdown/marked.js' },
{ src: 'plugin/markdown/markdown.js' },
{ src: 'plugin/notes/notes.js', async: true },
{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
]
});
</script>
<div class="footer" style="position: absolute; width: 100%; bottom: 0px; padding: 1.2em; background-image: url(lightbend-reverse.svg); height: 3em; background-color: #15a9ce; background-repeat: no-repeat; background-origin: content-box"></div>
</body>
</html>
